package osgi.quartz.scheduler.consumer.jobs;

import java.util.Date;

import org.apache.log4j.Logger;

import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.JobKey;

import org.quartz.DisallowConcurrentExecution;
import org.quartz.PersistJobDataAfterExecution;


/**
 * <p>
 * A job dumb job that will throw a job execution exception
 * </p>
 * 
 * @author Bill Kratzer
 */
@PersistJobDataAfterExecution
@DisallowConcurrentExecution
public class BadJob1 implements Job {
	private static Logger logger = Logger.getLogger(BadJob1.class);

	@SuppressWarnings("unused")
	private int calculation = 0;

	/**
	 * Empty public constructor for job initialization
	 */
	public BadJob1() {
	}

	/**
	 * <p>
	 * Called by the <code>{@link org.quartz.Scheduler}</code> when a <code>{@link org.quartz.Trigger}</code> fires that
	 * is associated with the <code>Job</code>.
	 * </p>
	 * 
	 * @throws JobExecutionException if there is an exception while executing the job.
	 */
	public void execute(JobExecutionContext context) throws JobExecutionException {
		JobKey jobKey = context.getJobDetail().getKey();
		JobDataMap dataMap = context.getJobDetail().getJobDataMap();

		int denominator = dataMap.getInt("denominator");
		
		logger.info("---" + jobKey + " executing at " + new Date() + " with denominator " + denominator);

		// a contrived example of an exception that
		// will be generated by this job due to a
		// divide by zero error (only on first run)
		try {
			this.calculation = 4815 / denominator;
		} catch (Exception exception) {
			logger.info("--- Error in job!");
			
			JobExecutionException execution = new JobExecutionException(exception);

			// fix denominator so the next time this job run
			// it won't fail again
			dataMap.put("denominator", "1");

			// this job will refire immediately
			execution.setRefireImmediately(true);
			
			throw execution;
		}

		logger.info("---" + jobKey + " completed at " + new Date());
	}
}